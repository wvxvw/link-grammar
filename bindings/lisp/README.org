* link-grammar parser
  It looks like the best way to do it right now is to

  #+BEGIN_SRC sh
    cd ~/Projects
    mkdir link-grammar
    cd ./link-grammar
    wget http://www.abisource.com/downloads/link-grammar/5.0.8/link-grammar-5.0.8.tar.gz
    tar -zxf ./link-grammar-5.0.8.tar.gz
    cd ./link-grammar-5.0.8
    ./configure
    make
    sudo make install
  #+END_SRC

  This should build and install the link-grammar parser (most importantly, it will put
  the link-grammar.so on the =$PATH=, so that we can easily link against it, when
  compiling Lisp bindings.

  The clinkgrammar.lisp found in this repository is a slightly altered output of what
  was generated by SWIG. The code I used to generate it is:

  #+BEGIN_SRC sh
    cd ~/Projects/link-grammar/link-grammar-5.0.8/bindings/lisp
    swig -cffi -module clinkgrammar -I../../link-grammar \
        -o ./clinkgrammar.lisp ../swig/link_grammar.i
  #+END_SRC

  I added the =in-package= code, but that's about all I did. In fact, the link_grammar.i
  interface can be modified to do that automatically, so we probably shouldn't version
  the clinkgrammar.lisp in the future, I am adding it here just to make sure we get the
  same or equivalent result. I think that if we want to continue to work on the bindings,
  than the best way to go about it would be to add (as little as possible) changes to
  the SWIG interface (which we could later ask the project developers to incorporate
  into their project), and to write the code that provides better abstraction to the
  C API separately. Maybe, for now, until the maintainers didn't update the interface
  we could ourselves host the modified version of the interface.

* Examples
  I've copied this example from: [[http://www.abisource.com/projects/link-grammar/api/index.html][www.abisource.com]].
  
  #+BEGIN_SRC c
    #include <locale.h>
    #include <stdio.h>
    #include "link-includes.h"
    
    int main()
    {
      Dictionary    dict;
      Parse_Options opts;
      Sentence      sent;
      Linkage       linkage;
      char *        diagram;
      int           i, num_linkages;
      char *        input_string[] = {
        "Grammar is useless because there is nothing to say -- Gertrude Stein.",
        "Computers are useless; they can only give you answers -- Pablo Picasso."};
    
      setlocale(LC_ALL, "");
      opts = parse_options_create();
      dict = dictionary_create_lang("en");
      if (!dict) {
        printf ("Fatal error: Unable to open the dictionary\n");
        return 1;
      }
    
      for (i=0; i<2; ++i) {
        sent = sentence_create(input_string[i], dict);
        sentence_split(sent, opts);
        num_linkages = sentence_parse(sent, opts);
        if (num_linkages > 0) {
          linkage = linkage_create(0, sent, opts);
          printf("%s\n", diagram = linkage_print_diagram(linkage, 1, 80));
          linkage_free_diagram(diagram);
          linkage_delete(linkage);
        }
        sentence_delete(sent);
      }
    
      dictionary_delete(dict);
      parse_options_delete(opts);
      return 0;
    }
  #+END_SRC

  Below is the equivalent code in Lisp:

  #+BEGIN_SRC lisp
    (in-package :link-grammar)
    
    (defun test-hello-world ()
      (with-dictionary (en)
        (with-options (opts)
          (loop :for saying :in
             (list "Grammar is useless because there is nothing to say -- Gertrude Stein."
                   "Computers are useless; they can only give you answers -- Pablo Picasso.")
             :do (with-sentence (sent saying)
                   (split sent opts)
                   (with-linkage (link)
                     (format t "~&diagram:~&~s" (print-diagram link))))))))
  #+END_SRC
